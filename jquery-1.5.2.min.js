/ *!
 * jQuery JavaScript Library v1.5.2
 * http://jquery.com/
 *
 * Copyright 2011, Джон Резиг
 * Двойная лицензия по лицензии MIT или GPL версии 2.
 * http://jquery.org/license
 *
 * Включает Sizzle.js
 * http://sizzlejs.com/
 * Copyright 2011, Фонд Додзё
 * Выпущено по лицензиям MIT, BSD и GPL.
 *
 * Дата: четверг, 31 марта, 15:28:23 2011 -0400
 * /
(function (a, b) {function ci (a) {return d.isWindow (a)? a: a.nodeType === 9? a.defaultView || a.parentWindow:! 1} function cf (a) { if (! b_ [a]) {var b = d ("<" + a + ">"). appendTo ("body"), c = b.css ("display"); b.remove (); if ( c === "none" || c === "") c = "block"; b_ [a] = c} return b_ [a]} функция ce (a, b) {var c = {}; d .each (cd.concat.apply ([], cd.slice (0, b)), function () {c [this] = a}); return c} function b $ () {try {return new a. ActiveXObject ("Microsoft.XMLHTTP")} catch (b) {}} функция bZ () {try {return new a.XMLHttpRequest} catch (b) {}} функция bY () {d (a) .unload (function ( ) {for (var a in bW) bW [a] (0,1)})} функция bS (a, c) {a.dataFilter && (c = a.dataFilter (c, a.dataType)); var e = a.dataTypes, F = {}, G, H, I = e.length, J, K = E [0], L, M, N, O, P, ибо (г = 1; г <я; г ++) {if (g === 1) для (h в a.converters) typeof h === "string" && (f [h.toLowerCase ()] = a.converters [h]); l = k, k = e [g]; if (k === "*") k = l; иначе if (l! == "*" && l! == k) {m = l + "" + k, n = f [m] || f ["*" + k]; if (! n) {p = b; для (o в f) {j = o .split (""); if (j [0] === l || j [0] === "*") {p = f [j [1] + "" + k]; if (p) {o = f [o], o ===! 0? n = p: p ===! 0 && (n = o); перерыв}}}}! n &&! p && d.error ("Нет преобразования из" + m .replace ("", "to")), n! ==! 0 && (c = n? n (c): p (o (c)))}} return c} функция bR (a, c, d) {var e = a.contents, f = a.dataTypes, g = a.responseFields, h, i, j, k; для (i в g) i в d && (c [g [i]] = d [i] ), тогда как (е [0] === "*") f.shift (), ч === б && (ч = a.mimeType || c.getResponseHeader ( "тип содержимого")); если (ч) for (i in e) if (e [i] && e [i] .test (h)) {f.unshift (i); break} if (f [0] in d) j = f [0]; else { for (i in d) {if (! f [0] || a.converters [i + "" + f [0]]) {j = i;break} k || (k = i)} j = j || k} if (j) {j! == f [0] && f.unshift (j); вернуть функцию d [j]}} bQ (a, б, в, е) {если (d.isArray (б) && b.length) d.each (б, функция (Ь, е) {с || bs.test (а) е (а, е): Ьо (a + "[" + (typeof f === "object" || d.isArray (f)? b: "") + "]", f, c, e)}); иначе, если (c || b == null || typeof b! == "object") e (a, b), иначе if (d.isArray (b) || d.isEmptyObject (b)) e (a, ""); еще для ( var f в b) bQ (a + "[" + f + "]", b [f], c, e)} функция bP (a, c, d, e, f, g) {f = f || c. dataTypes [0], g = g || {}, g [f] =! 0; var h = a [f], i = 0, j = h? h. Длина: 0, k = a === bJ , l; для (; i <j && (k ||! l); i ++) l = h [i] (c, d, e), typeof l === "string" && (! k || g [l ] л = Ь:!! (c.dataTypes.unshift (л), л = ЬР (а, с, д, е, л, г))); (к || л) && г [ "*"] && (l = bP (a, c, d, e, "*", g)); return l} function bO (a) {return function (b, c) {typeof b! == "string" && (c = b, b = "*"); if (d.isFunction (c)) {var e = b.toLowerCase (). split (bD), f = 0, g = длина e, h, i , J, ибо (; е <г; е ++), ч = е [е], J = / ^ \ + / испытание (ч), J && (ч = h.substr (1) || "*"), я. = a [h] = a [h] || [], i [j? "unshift": "push"] (c)}}} функция bq (a, b, c) {var e = b === "width"? bk: bl, f = b === "width"? a.offsetWidth: a.offsetHeight; if (c === "border") возвращает f; d.each (e, function () {c || (F- = parseFloat (d.css (а, "обивка" + это)) || 0), с === "запас"? F + = parseFloat (d.css (а, "запас" + это) ) || 0: f- = parseFloat (d.css (a, «border» + this + «Width»)) || 0}); return f} функция bc (a, b) {b.src? D.ajax ({URL: b.src, асинхронная: 1, DATATYPE: "сценарий"}): d.globalEval (b.text || b.textContent || b.innerHTML || ""), b.parentNode && b.parentNode. removeChild (b)} функция bb (a) {return "getElementsByTagName "в a? a.getElementsByTagName (" * "):" querySelectorAll "в? a.querySelectorAll (" * "): []} функция ba (a, b) {if (b.nodeType === 1) {var c = b.nodeName.toLowerCase (); b.clearAttributes (), b.mergeAttributes (a); if (c === "object") b.outerHTML = a.outerHTML; еще if (c! == "input" || a.type! == "checkbox" && a.type! == "radio") {if (c === "option") b.selected = a.defaultSelected; еще if (c === "input" || c === "textarea") b.defaultValue = a.defaultValue} еще a.checked && (b.defaultChecked = b.checked = a.checked), b.value! == a.value && (b .value = a.value); b.removeAttribute (d.expando)}} function _ (a, b) {if (b.nodeType === 1 && d.hasData (a)) {var c = d.expando, e = d.data (a), f = d.data (b, e); if (e = e [c]) {var g = e.events; f = f [c] = d.extend ({}, e); if (g) {удалить f.handle, f.events = {};for (var h в g) для (var i = 0, j = g [h] .length; i <j; i ++) d.event.add (b, h + (g [h] [i] .namespace? " . ":" ") + g [h] [i] .namespace, g [h] [i], g [h] [i] .data)}}}} функция $ (a, b) {return d. nodeName (a, "table")? a.getElementsByTagName ("tbody") [0] || a.appendChild (a.ownerDocument.createElement ("tbody")): a} функция Q (a, b, c) { if (d.isFunction (b)) возвращает d.grep (a, function (a, d) {var e = !! b.call (a, d, a); возвращает e === c}); if ( b.nodeType) return d.grep (a, function (a, d) {return a === b === c}); if (typeof b === "string") {var e = d.grep ( a, function (a) {return a.nodeType === 1}); if (L.test (b)) возвращает d.filter (b, e,! c); b = d.filter (b, e) } return d.grep (a, function (a, e) {return d.inArray (a, b)> = 0 === c})} function P (a) {return! a ||! a.parentNode | | a.parentNode.nodeType === 11} функция H (a, b) {return (a && a! == "*"? a + ".": "") + b.replace (t, "`") .replace (u, "&")} функция G (a) {var b, c, e, f, g, h, i, j, k, l, m, n, o, p = [] , д = [], s = d._data (это, "события");!! если (a.liveFired == это && s && && s.live a.target.disabled && (a.button || a.type ==» нажмите ")) {a.namespace && (n = new RegExp (" (^ | \\.) "+ a.namespace.split (". "). join (" \\. (?:. * \\.) ? ") +" (\\. | $) ")), a.liveFired = this; var t = s.live.slice (0); для (i = 0; i <t.length; i ++) g = т [I], g.origType.replace (г "") === a.type q.push (g.selector): t.splice (я - 1); F = d (a.target ) .closest (кв, a.currentTarget), для (J = 0, к = f.length, J <к; j ++) {т = F [J], для (I = 0; я <t.length; я ++ ) {г = т [I];! если (! m.selector === g.selector && (п || n.test (g.namespace)) && m.elem.disabled) {ч = m.elem, е = NULL; если (g.preType === "MouseEnter" || g.preType === "MouseLeave") a.type = g.preType,е = д (a.relatedTarget) .closest (g.selector) [0]; && p.push ({элем: ч, handleObj: г, уровень: m.level}) (е || е == ч!!) }}} для (J = 0, к = p.length, J <к; j ++) {F = P [J], если (с && f.level> с) перерыва; a.currentTarget = f.elem, a.data = f.handleObj.data, a.handleObj = f.handleObj, о = f.handleObj.origHandler.apply (f.elem, аргументы); если (! о === 1 || a.isPropagationStopped ()) {с = f.level, o ===! 1 && (b =! 1); if (a.isImmediatePropagationStopped ()) break}} return b}} функция E (a, c, e) {var f = d.extend ( {}, е [0]); f.type = а, f.originalEvent = {}, f.liveFired = Ь, d.event.handle.call (C, F), f.isDefaultPrevented () && е [0] .preventDefault ()} function y () {return! 0} function x () {return! 1} function i (a) {for (var b in a) if (b! == "toJSON") return! 1; return! 0} функция h (a, c, e) {if (e === b && a.nodeType === 1) {e = a.getAttribute ("data -" + c); if (typeof e === "строка") {попытка {е = е === "истинный" 0?!:е === "ложь" 1:! е === "нуль" нуль:? d.isNaN (е) g.test (е) d.parseJSON (е): е: parseFloat (е)} поймать (f) {} d.data (a, c, e)} иначе e = b} return e} var c = a.document, d = function () {function G () {if (! d.isReady) { try {c.documentElement.doScroll ("left")} catch (a) {setTimeout (G, 1); return} d.ready ()}} var d = function (a, b) {вернуть новый d.fn. . INIT (а, б, г)}, е = a.jQuery, е = а $, г, ч = / ^ (?: [^ <] * (<[\ ш \ W] +>) [^> ] * $ | # ([\ ш \ -] +) $) /, г = / \ S /, J = / ^ \ s + /, к = / \ S + $ /, л = / \ д /, т = / ^ <(\ W +) \ s * \ /?> (?: <\ / \ 1>) $ /, п = / ^ [\],: {} \ s] * $ /, о = / \ \ (?: [ "\\\ / bfnrt] | и [0-9a-FA-F] {4}) / г, р = /" [^ "\\\ п \ г] *" | истинная | ложная | пустой | - \ d +? (: \ \ d *?.): - / г, д = /? ([еЕ] [+ \] \ d +?)? ((:: ^ | |,?)? : \ s * \ [) + / g, r = / (webkit) [\ /] ([\ w.] +) /, s = / (опера) (?:. * версия)? [\ /] ( [\ w.] +) /, t = / (msie) ([\ w.] +) /, u = / (mozilla) (?:. *? rv: ([\ w.] +))? / , v = navigator.userAgent, W, X, Y, Z = Object.prototype.toString, А = Object.prototype.hasOwnProperty, В = Array.prototype.push, С = Array.prototype.slice D = String.prototype.trim, Е = Array.prototype.indexOf, Р = {}; d.fn = d.prototype = {конструктор: d, init: function (a, e, f) {var g, i, j, k; if (! a) возвращает this; if (a.nodeType) {this.context = this [0] = a, this. length = 1; вернуть this} if (a === "body" &&! e && c.body) {this.context = c, this [0] = c.body, this.selector = "body", this.length = 1; вернуть это} if (typeof a === "string") {g = h.exec (a); if (! G ||! G [1] && e) вернуть! E || e.jquery? (E || f) .find (a): this.constructor (e) .find (a); if (g [1]) {e = e instanceof d? e [0]: e, k = e? e.ownerDocument || е: C, J = m.exec (а), J d.isPlainObject (е) (а = [c.createElement (к [1])], d.fn.attr.call (а, е , 0)): а = [k.createElement (к [1])] :( J = d.buildFragment ([г [1]], [к]), а = (j.cacheable d.clone (? j.fragment): j.fragment) .childNodes); вернуть d.merge (this, a)} i = c.getElementById (g [2]); if (i && i.parentNode) {if (i.id! == g [2]) вернуть f.find (a); this.length = 1, this [0] = i} this.context = c, this.selector = a; вернуть this} if (d.isFunction (a)) возвращает f.ready (a); a.selector! == b && (this.selector = a.selector, this.context = a.context); возвращает d.makeArray (a , this)}, селектор: "", jquery: "1.5.2", длина: 0, size: function () {return this.length}, toArray: function () {return C.call (this, 0)} , get: function (a) {return a == null? this.toArray (): a <0? this [this.length + a]: this [a]}, pushStack: function (a, b, c) { var e = this.constructor (); d.isArray (a)? B.apply (e, a): d.merge (e, a), e.prevObject = this, e.context = this.context, b = == "find"? e.selector = this.selector + (this.selector? "": "") + c: b && (e.selector = this.selector + "." + b + "(" + c + ")") ; return e}, каждый: function (a, b) {return d.each (this, a, b)}, ready: function (a) {d.bindReady (), x.done (a); вернуть this}, eq: function (a) {return a === - 1? this.slice (a): this.slice (a, + a + 1)}, first: function () { return this.eq (0)}, last: function () {return this.eq (-1)}, slice: function () {return this.pushStack (C.apply (this, arguments), "slice", C .call (arguments) .join (","))}, map: function (a) {вернуть this.pushStack (d.map (this, function (b, c)) {вернуть a.call (b, c, b )}))}, end: function () {вернуть this.prevObject || this.constructor (null)}, push: B, sort: []. sort, splice: []. splice}, d.fn.init .prototype = d.fn, d.extend = d.fn.extend = function () {var a, c, e, f, g, h, i = аргументы [0] || {}, j = 1, k = arguments.length, l =! 1; typeof i === "boolean" && (l = i, i = arguments [1] || {}, j = 2), typeof i! == "object" &&! d.isFunction (я) && (я = {}), к === J && (я = это, - к), ибо (; J <к; j ++), если ((а = аргументы [у]) =! null) для (c в a) {e = i [c], f = a [c]; если (i === f) продолжить; l && f && (D.isPlainObject (е) || (г = d.isArray (е))) (г (г = 1, ч = е && d.isArray (е) е:?!? []): Ч = е && д. isPlainObject (e)? e: {}, i [c] = d.extend (l, h, f)): f! == b && (i [c] = f)} return i}, d.extend ({ noConflict: function (b) {a. $ = f, b && (a.jQuery = e); return d}, isReady:! 1, readyWait: 1, ready: function (a) {a ===! 0 && d.readyWait -; if (! d.readyWait || a! ==! 0 &&! d.isReady) {if (! c.body) вернуть setTimeout (d.ready, 1); d.isReady =! 0; if (a ! == 0 && - d.readyWait> 0) возвращение;!. x.resolveWith (с, [d]), d.fn.trigger && d (с) .trigger ( "готов") отвязать ( "готов")}} , bindReady: function () {if (! x) {x = d._Deferred (); if (c.readyState === "complete") вернуть setTimeout (d.ready, 1); if (c.addEventListener) c .addEventListener ("DOMContentLoaded", y,! 1), a.addEventListener ("load", d.ready,! 1); иначе, если (c.attachEvent) {c.attachEvent ("onreadystatechange ", y), a.attachEvent (" onload ", d.ready); var b =! 1; try {b = a.frameElement == null} catch (e) {} c.documentElement.doScroll && b && G ()} }}, isFunction: function (a) {return d.type (a) === "function"}, isArray: Array.isArray || function (a) {return d.type (a) === "array" }, isWindow: function (a) {вернуть && typeof a === "object" && "setInterval" в a}, isNaN: function (a) {вернуть a == null ||! l.test (a) || isNaN (a)}, тип: function (a) {return a == null? String (a): F [z.call (a)] || "объект"}, isPlainObject: function (a) {if (! a || d.type (а) == "объект" || a.nodeType || d.isWindow (а)) возвращение 1;! если (a.constructor && A.call (а, "конструктор"!) &&! A.call (a.constructor.prototype, "isPrototypeOf")) return! 1; var c; for (c in a) {} return c === b || A.call (a, c)}, isEmptyObject:function (a) {for (var b in a) return! 1; return! 0}, ошибка: function (a) {throw a}, parseJSON: function (b) {if (typeof b! == "string" | |! b) вернуть null; b = d.trim (b); if (n.test (b.replace (o, "@"). replace (p, "]"). replace (q, "")) ) return a.JSON && a.JSON.parse? a.JSON.parse (b) :( новая функция ("return" + b)) (); d.error ("неверный JSON:" + b)}, parseXML: function (b, c, e) {a.DOMParser? (e = новый DOMParser, c = e.parseFromString (b, "text / xml")) :( c = новый ActiveXObject ("Microsoft.XMLDOM"), c.async = "false", c.loadXML (b)), e = c.documentElement, (! e ||! e.nodeName || e.nodeName === "parsererror") && d.error ("Неверный XML:" + b); return c}, noop: function () {}, globalEval: function (a) {if (a && i.test (a)) {var b = c.head || c.getElementsByTagName ("head") [0 ] || c.documentElement, е = с.createElement ( "сценарий"); d.support.scriptEval () e.appendChild (c.createTextNode (а)): e.text = а, b.insertBefore (е, b.firstChild), b.removeChild (е) }}, nodeName: function (a, b) {return a.nodeName && a.nodeName.toUpperCase () === b.toUpperCase ()}, каждый: function (a, c, e) {var f, g = 0, h = a.length, i = h === b || d.isFunction (a); if (e) {if (i) {для (f в a) if (c.apply (a [f], e ) ===! 1) break} else for (; g <h;) if (c.apply (a [g ++], e) ===! 1) break} else if (i) {for (f в a ) if (c.call (a [f], f, a [f]) ​​===! 1) break} else для (var j = a [0]; g <h && c.call (j, g, j) ! ==! 1; j = a [++ g]) {} return a}, trim: D? Function (a) {return a == null? "": D.call (a)}: function (a ) {return a == null? "" :( a + ""). replace (j, ""). replace (k, "")}, makeArray: function (a, b) {var c = b || [ ]; if (a! = null) {var e = d.type (a); a.length == null || e === "string" || e === "function" || e === "regexp "|| d.isWindow (a)? B.call (c, a): d.merge (c, a)} return c}, inArray: function (a, b) {if (b.indexOf) вернуть b .indexOf (a); для (var c = 0, d = b.length; c <d; c ++) if (b [c] === a) return c; return-1}, merge: function (a, c) {var d = a.length, e = 0; if (typeof c.length === "number") для (var f = c.length; e <f; e ++) a [d ++] = c [e ]; в то время как (c [e]! == b) a [d ++] = c [e ++]; a.length = d; вернуть a}, grep: function (a, b, c) {var d = [] , e; c = !! c; для (var f = 0, g = a.length; f <g; f ++) e = !! b (a [f], f), c! == e && d.push ( a [f]); return d}, map: function (a, b, c) {var d = [], e; для (var f = 0, g = a.length; f <g; f ++) e = b (a [f], f, c), e! = null && (d [d.length] = e); return d.concat.apply ([], d)}, guid: 1, proxy: function (a , c, e) {arguments.length === 2 && (typeof c === "string"? (e = a, a = e [c], c = b): c &&! d.isFunction (c) && ( e = c, c = b)) ,! c && a && (c = function () {return a.apply (e || this, arguments)}), a && (c.guid = a.guid = a.guid || c.guid || d.guid ++); возврат c}, доступ: функция (a, c, e, f, g, h) {var i = a .length; if (typeof c === "object") {for (var j in c) d.access (a, j, c [j], f, g, e); вернуть a} if (e! = = b) {f =! h && f && d.isFunction (e); для (var k = 0; k <i; k ++) g (a [k], c, f? e.call (a [k], k, g (a [k], c)): e, h); return a} return i? g (a [0], c): b}, теперь: function () {return (new Date) .getTime ()} , uaMatch: function (a) {a = a.toLowerCase (); var b = r.exec (a) || s.exec (a) || t.exec (a) || a.indexOf («совместимый») ) <0 && u.exec (a) || []; return {browser: b [1] || "", версия: b [2] || "0"}}, sub: function () {function a (b , c) {вернуть новый a.fn.init (b, c)} d.extend (! 0, a, this), a.superclass = this, a.fn = a.prototype = this (), a.fn .constructor = a, a.subclass = this.subclass, a.fn.init = function b (b, c) {c && c instanceof d &&! (c instanceof a) && (c = a (c)); вернуть d.fn .в этом.call (this, b, c, e)}, a.fn.init.prototype = a.fn; var e = a (c); вернуть a}, браузер: {}}), d.each («логическое число» Строка Функция Массив Дата RegExp Object ".split (" "), function (a, b) {F [" [object "+ b +"] "] = b.toLowerCase ()}), w = d.uaMatch (v) , w.browser && (d.browser [w.browser]! = 0, d.browser.version = w.version), d.browser.webkit && (d.browser.safari =! 0), Е && (d.inArray = function (a, b) {return E.call (b, a)}), i.test ("") && (j = / ^ [\ s \ xA0] + /, k = / [\ s \ xA0] ? + $ /), г = д (с), c.addEventListener у = функция () {c.removeEventListener ( "DOMContentLoaded", у, 1), d.ready (!)}: c.attachEvent && (у = функция () {c.readyState === "complete" && (c.detachEvent ("onreadystatechange", y), d.ready ())}); return d} (), e = "затем выполнено сбой isResolved isRejected обещание" .split (""), f = []. slice; d.extended ({_ Deferred: function () {var a = [], b, c, e, f = {done: function () {if (! e) {var c = аргументы, g, h, i, j, k б && (к = Ь, Ь = 0), для (г = 0, ч = c.length; г <ч; г ++), I = C [G], J = d.type (я), J === «массив»? f.done.apply (f, i): j === «функция» && a.push (i); k && f.resolveWith (k [0], k [1])} вернуть это}, resolWith: функция (д, е) {если (е && && Ь с!!!) {F = F || [], с = 1;. {попытка в то время как (а [0]) a.shift () применяются (д, е) } наконец {b = [d, f], c = 0}} вернуть это}, разрешить: function () {f.resolveWith (это, аргументы); вернуть это}, isResolved: function () {return c || b }, cancel: function () {e = 1, a = []; вернуть это}}; вернуть f}, отложено: function (a) {var b = d._Deferred (), c = d._Deferred (), f; d.extend (b, {then: function (a, c) {b.done (a) .fail (c); вернуть это}, fail: c.done, rejectWith: c.resolveWith, reject: c. решить, isRejected: c.isResolved, обещание: function (a) {if (a == null) {if (f) вернуть f; f = a = {}} var c = e.length;в то время как (c -) a [e [c]] = b [e [c]]; вернуть a}}), b.done (c.cancel) .fail (b.cancel), удалить b.cancel, a && a .call (b, b); return b}, когда: function (a) {function i (a) {return function (c) {b [a] = arguments.length> 1? f.call (arguments, 0) : c, - g || h.resolveWith (h, f.call (b, 0))}} var b = аргументы, c = 0, e = b.length, g = e, h = e <= 1 && a && d .isFunction (a.promise): с d.Deferred (); если (е> 1) {для (С <е; C ++) B [C] && d.isFunction (б [с] .promise) б [? c] .promise (). then (i (c), h.reject): - g; g || h.resolveWith (h, b)} else h! == a && h.resolveWith (h, e? [a ]: []); return h.promise ()}}), function () {d.support = {}; var b = c.createElement ("div"); b.style.display = "none", b .innerHTML = "<link /> <таблица> </ table> <a href='/a' style='color:red;float:left;opacity:.55;'> a </a> <тип ввода = 'checkbox' /> "; var e = b.getElementsByTagName ( "*"), е = b.getElementsByTagName ( "а") [0], г = c.createElement ( "выбрать"), ч = g.appendChild (c.createElement ( "вариант")), г = b.getElementsByTagName ( "вход") [0]; если (е && && e.length е) {d.support = {leadingWhitespace:!. b.firstChild.nodeType === 3, TBODY: b.getElementsByTagName ( "TBODY") длина, htmlSerialize:. !! b.getElementsByTagName ( "ссылка") длина, стиль: /red/.test (f.getAttribute ( "стиль")), hrefNormalized: f.getAttribute ( "HREF") === "/ а" , непрозрачности.: / ^ 0,55 $ / тест (f.style.opacity), cssFloat: !! f.style.cssFloat, checkOn: i.value === "на", optSelected: h.selected, deleteExpando: 0 , optDisabled: 1, checkClone: ​​1, noCloneEvent: 0, noCloneChecked: 0, boxModel: нуль, inlineBlockNeedsLayout: 1, shrinkWrapBlocks: 1, reliableHiddenOffsets: 0, reliableMarginRight: 0}, я.check =! 0, d.support.noCloneChecked = i.cloneNode (! 0) .checked, g.disabled =! 0, d.support.optDisabled =! h.disabled; var j = null; d.support.scriptEval = function () {if (j === null) {var b = c.documentElement, e = c.createElement ("script"), f = "script" + d.now (); try {e.appendChild (c .createTextNode ("window." + f + "= 1;"))} catch (g) {} b.insertBefore (e, b.firstChild), a [f]? (j =! 0, удалить a [f] ): j =! 1, b.removeChild (e)} return j}; try {delete b.test} catch (k) {d.support.deleteExpando =! 1}! b.addEventListener && b.attachEvent && b.fireEvent && (b. attachEvent ("onclick", function l () {d.support.noCloneEvent =! 1, b.detachEvent ("onclick", l)}), b.cloneNode (! 0) .fireEvent ("onclick")), b = c.createElement ("div"), b.innerHTML = "<input type = 'radio' name = 'radiotest' checked = 'checked' />"; var m = c.createDocumentFragment (); m.appendChild (b.firstChild), d.support.checkClone = m.cloneNode (! 0) .cloneNode (! 0) .lastChild.checked, d (function () {var а = c.createElement ( "DIV"), б = c.getElementsByTagName ( "тело") [0]; если (б) {a.style.width = a.style.paddingLeft = "1px", b.appendChild ( a), d.boxModel = d.support.boxModel = a.offsetWidth === 2, «увеличение» в a.style && (a.style.display = "inline", a.style.zoom = 1, d.support .inlineBlockNeedsLayout = a.offsetWidth === 2, a.style.display = "", a.innerHTML = "<div style = 'width: 4px;'> </ div>", d.support.shrinkWrapBlocks = a. offsetWidth! == 2), a.innerHTML = "<table> <tr> <td style = 'padding: 0; border: 0; display: none'> </ td> <td> t </ td> </ tr> </ table> "; var e = a.getElementsByTagName (" td "); d.support.reliableHiddenOffsets = е [0] .offsetHeight === 0, е [0] .style.display = "", е [1] .style.display = "нет", d.support.reliableHiddenOffsets = d.support.reliableHiddenOffsets && е [ 0] .offsetHeight === 0, a.innerHTML = "", c.defaultView && && c.defaultView.getComputedStyle (a.style.width = "1px", a.style.marginRight = "0", d.support.reliableMarginRight = (ParseInt (c.defaultView.getComputedStyle (а, нулевой) .marginRight, 10) || 0) === 0), b.removeChild (а) .style.display = "нет", а = е = NULL}} ); var n = function (a) {var b = c.createElement ("div"); a = "on" + a; if (! b.attachEvent) вернет! 0; var d = a в b; d | | (b.setAttribute (a, "return;"), d = typeof b [a] === "function"); return d}; d.support.submitBubbles = n ("submit"), d.support. changeBubbles = n ("change"), b = e = f = null}} (); var g = / ^ (?: \ {. * \} | \ [.* \]) $ /; D.extend. ({Кэш: {}, UUID: 0, Expando: "JQuery" + (d.fn.jquery + Math.random ()) заменить (/ \ D / г,» "), NoData: {встраивать: 0, объект:" CLSID: D27CDB6E-AE6D-11cf-96B8-444553540000" , апплет: 0}, hasData: функция (а) {а = a.nodeType d.cache [ а [d.expando]]: а [d.expando]; возвращение !! && я (а)}, данные: функция (а, с, д, е) {если (d.acceptData (а)) {вар g = d.expando, h = typeof c === "string", i, j = a.nodeType, k = j? d.cache: a, l = j? a [d.expando]: a [d. Expando] && d.expando; если ((л || е л && && к [л] [г]) && && ч е === б!) возвращение; || л (J а [d.expando] = л = ++ d?. uuid: l = d.expando), k [l] || (k [l] = {}, j || (k [l] .toJSON = d.noop)); if (typeof c === "object "|| typeof c ===" function ") f? k [l] [g] = d.extend (k [l] [g], c): k [l] = d.extend (k [l] , с);! я = K [L], F && (я [г] || (я [г] = {}), I = I [г]), е == б && (я [с] = е) , если (с === «событий» &&!i [c]) return i [g] && i [g] .events; return h? i [c]: i}}, removeData: function (b, c, e) {if (d.acceptData (b)) { var f = d.expando, g = b.nodeType, h = g? d.cache: b, j = g? b [d.expando]: d.expando; if (! h [j]) возврат; if ( c) {var k = e? h [j] [f]: h [j]; if (k) {delete k [c]; if (! i (k)) return}} if (e) {delete h [j] [f]; if (! i (h [j])) return} var l = h [j] [f]; d.support.deleteExpando || h! = a? удалить h [j]: h [J] = NULL, L (H [J] = {}, г || (ч [J] .toJSON = d.noop), ч [J] [е] = л): г && (d.support. deleteExpando? удалить b [d.expando]: b.removeAttribute? b.removeAttribute (d.expando): b [d.expando] = null)}}, _ data: function (a, b, c) {вернуть d.data (a, b, c,! 0)}, acceptData: function (a) {if (a.nodeName) {var b = d.noData [a.nodeName.toLowerCase ()]; if (b) вернуть b! = =! 0 && a.getAttribute ("classid") === b} return! 0}}), d.fn.extend ({data: function (a, c) {var e = null; if (typeof a ===) "неопределенное") {если (this.length) {е = d.data (это [0]); если (это [0].nodeType === 1) {var f = this [0] .atributes, g; для (var i = 0, j = f.length; i <j; i ++) g = f [i] .name, g.indexOf ("data -") === 0 && (g = g.substr (5), h (this [0], g, e [g]))}} return e} if (typeof a === "object" ) вернуть this.each (function () {d.data (this, a)}); var k = a.split ("."); k [1] = k [1]? "." + k [1 ]: ""; если (с === б) {е = this.triggerHandler ( "GetData" + к [1] ​​+ "!", [к [0]]), е === б && this.length && (е = d.data (this [0], a), e = h (this [0], a, e)); return e === b && k [1]? this.data (k [0]): e} вернуть this.each (function () {var b = d (this), e = [k [0], c]; b.triggerHandler ("setData" + k [1] + "!", e), d. data (this, a, c), b.triggerHandler ("changeData" + k [1] + "!", e)})}, removeData: function (a) {вернуть this.each (function () {d. removeData (это, а)})}}), d.extend ({очереди: функция (а, б, в) {если (а) {Ь = (Ь || "FX") +»queue "; var e = d._data (a, b); if (! c) возвращает e || [] ;! e || d.isArray (c)? e = d._data (a, b, d. makeArray (c)): e.push (c); return e}}, dequeue: function (a, b) {b = b || "fx"; var c = d.queue (a, b), e = c.shift (); е === "InProgress" && (е = c.shift ()), е && (б === "FX" && c.unshift ( "InProgress"), e.call (а, функция ( ) {d.dequeue (а, б)})), c.length || d.removeData (а, Ь + "очереди", 0)}}), d.fn.extend ({очереди: функция (а, c) {typeof a! == "string" && (c = a, a = "fx"); if (c === b) вернуть d.queue (this [0], a); вернуть this.each ( function (b) {var e = d.queue (this, a, c); a === "fx" && e [0]! == "inprogress" && d.dequeue (this, a)})}, снять очередь: function (a) {return this.each (function () {d.dequeue (this, a)})}, delay: function (a, b) {a = d.fx? d.fx.speeds [a] | | a: a, b = b || "fx"; вернуть this.queue (b, function () {var c = this;setTimeout (function () {d.dequeue (c, b)}, a)})}, clearQueue: function (a) {вернуть this.queue (a || "fx", [])}}); var j = / [\ п \ т \ г] / г, к = / \ s + /, л = / \ г / г, т = / ^ (?: HREF | SRC | стиль) $ /, п = / ^ (? : кнопка | вход) $ / я, о = ^ (кнопка / ?: | ввод | объект | выбрать | текстовое поле) $ / я, р = / ^ а (:? Субъективная) $ / я, д = / ^ ( : радио | Checkbox) $ / I; d.props = { "за": "htmlFor", "класс": "имя класса", только для чтения: "доступен только для чтения", MAXLENGTH: "MAXLENGTH", CELLSPACING: "CELLSPACING", RowSpan : "rowSpan", colspan: "colSpan", tabindex: "tabIndex", usemap: "useMap", frameborder: "frameBorder"}, d.fn.extend ({attr: function (a, b) {return d.access (this, a, b,! 0, d.attr)}, removeAttr: function (a, b) {вернуть this.each (function () {d.attr (this, a, ""), this.nodeType = == 1 && this.removeAttribute (а)})}, addClass: функция (а) {если (д.isFunction (a)) возвращает this.each (function (b) {var c = d (this); c.addClass (a.call (this, b, c.attr ("class")))}); if ( a && typeof a === "string") {var b = (a || ""). split (k); для (var c = 0, e = this.length; c <e; c ++) {var f = this [c]; if (f.nodeType === 1) if (f.className) {var g = "" + f.className + "", h = f.className; для (var i = 0, j = b. длина; i <j; i ++) g.indexOf ("" + b [i] + "") <0 && (h + = "" + b [i]); f.className = d.trim (h)} иначе f .className = a}} вернуть this}, removeClass: function (a) {if (d.isFunction (a)) вернуть this.each (function (b) {var c = d (this); c.removeClass (a. call (this, b, c.attr ("class")))}); if (a && typeof a === "string" || a === b) {var c = (a || ""). split (k); для (var e = 0, f = this.length; e <f; e ++) {var g = this [e]; if (g.nodeType === 1 && g.className) if (a) {var h = ("" + g.className + "") .replace (j, ""); для (var i = 0, l = c.length; i <l; i ++) h = h.replace ("" + c [i] + "", " "); g.className = d.trim (h)} иначе g.className =" "}} вернуть это}, toggleClass: function (a, b) {var c = typeof a, e = typeof b ===" boolean "; if (d.isFunction (a)) возвращает this.each (function (c) {var e = d (this); e.toggleClass (a.call (this, c, e.attr (" class ") , b), b)}); вернуть this.each (function () {if (c === "string") {var f, g = 0, h = d (this), i = b, j = a .split (k); while (f = j [g ++]) i = e? i:! h.hasClass (f), h [i? "addClass": "removeClass"] (f)} иначе if (c = == "не определено" || с === "логическое") this.className && d._data (это, "__ __ имя класса", this.className), this.className = this.className || ===! 1? "" : d._data (это, "__ __ имя класса") || ""})}, hasClass:function (a) {var b = "" + a + ""; for (var c = 0, d = this.length; c <d; c ++) if (("" + this [c] .className + ""). replace (j, "") .indexOf (b)> - 1) return! 0; return! 1}, val: function (a) {if (! arguments.length) {var c = this [0]; if ( c) {if (d.nodeName (c, "option")) {var e = c.attributes.value; вернуть! e || e.specified? c.value: c.text} if (d.nodeName (c , "select")) {var f = c.selectedIndex, g = [], h = c.options, i = c.type === "select-one"; если (f <0), вернуть ноль; for ( var j = i? f: 0, k = i? f + 1: h.length; j <k; j ++) {var m = h [j]; if (m.selected && (d.support.optDisabled?! m .disabled: m.getAttribute ( "отключено") === нуль) && (! m.parentNode.disabled || d.nodeName (m.parentNode, "OPTGROUP"))) {а = d (м) .val (); if (i) возвращает a; g.push (a)}} if (i &&! g.length && h.length) возвращает d (h [f]). val (); возвращает g} if (q.test ( Тип Ç) &&! d.support.checkOn) return c.getAttribute ("value") === null? "on": c.value; return (c.value || ""). replace (l, "")} return b} var n = d.isFunction (a); вернуть this.each (function (b) {var c = d (this), e = a; if (this.nodeType === 1) {n && (e = a .call (this, b, c.val ())), e == null? e = "": typeof e === "number"? e ​​+ = "": d.isArray (e) && (e = d .map (e, function (a) {return a == null? "": a + ""})); if (d.isArray (e) && q.test (this.type)) this.checked = d.inArray (c.val (), e)> = 0; иначе if (d.nodeName (this, "select")) {var f = d.makeArray (e); d ("option", this) .each (function () {this.selected = d.inArray (d (this) .val (), f)> = 0}), f.length || (this.selectedIndex = -1)} иначе this.value = e}} )}}), d.extend ({attrFn: {вал: 0, CSS: 0, HTML: 0, текст: 0, данные: 0, ширина: 0, высота: 0, смещение: ! 0}, атр: функция (а, в, д, е) {если (!a || a.nodeType === 3 || a.nodeType === 8 || a.nodeType === 2) вернуть b; если (f && c в d.attrFn) вернуть d (a) [c] (e ); var g = a.nodeType! == 1 ||! d.isXMLDoc (a), h = e! == b; c = g && d.props [c] || c; if (a.nodeType === 1) {var i = m.test (c); if (c === "selected" &&! D.support.optSelected) {var j = a.parentNode; j && (j.selectedIndex, j.parentNode && j.parentNode. selectedIndex)} if ((c в || a [c]! == b) && g &&! i) {h && (c === "type" && n.test (a.nodeName) && a.parentNode && d.error ("type свойство не может быть изменено "), e === null? a.nodeType === 1 && a.removeAttribute (c): a [c] = e); if (d.nodeName (a," form ") && a. getAttributeNode (c)) возвращает a.getAttributeNode (c) .nodeValue; if (c === "tabIndex") {var k = a.getAttributeNode ("tabIndex"); возвращает k && k.specified? k.value: o.test (а.имя узла) || p.test (a.nodeName) && a.href? 0: b} вернуть a [c]} if (! d.support.style && g && c === "style") {h && (a.style.cssText = "" + e); вернуть a.style.cssText} h && a.setAttribute (c, "" + e); if (! a.attributes [c] && (a.hasAttribute &&! a.hasAttribute (c))) вернуть b ; var l =! d.support.hrefNormalized && g && i? a.getAttribute (c, 2): a.getAttribute (c); return l === null? b: l} h && (a [c] = e); вернуть a [c]}}); var r = / \. (. *) $ /, s = / ^ (?: textarea | input | select) $ / i, t = / \ ./ g, u = / / g , v = / [^ \ w \ s. | `] / g, w = function (a) {return a.replace (v," \\ $ & ")}; d.event = {add: function (c , д, е, ж) {если (c.nodeType! == 3 && c.nodeType! == 8) {попытка {d.isWindow (с) && (с! == &&! c.frameElement) && (с = а )} catch (h) {} if (f ===! 1) f = x, иначе if (! f) return; var i, j; f.handler && (i = f, f = i.handler), f .guid || (f.guid = d.guid ++); var k = d._data (c); if (! k) return; var l = k.events, m = k.handle; l || (k.events = l = {}), m || (k.handle = m = function (a) {вернуть typeof d! == "undefined" && d.event.triggered! == a.type? d.event.handle.apply (m.elem, arguments): b} ), m.elem = c, e = e.split (""); var n, o = 0, p; while (n = e [o ++]) {j = i? d.extend ({}, i) : {обработчик: F, данные: г}, n.indexOf> - 1 (р = n.split (), п = p.shift (), j.namespace = p.slice ( " ")?"." (0) .sort (). присоединиться ( " ")) :( р = [], j.namespace =""), j.type = п, j.guid || (j.guid = f.guid) ; var q = l [n], r = d.event.special [n] || {}; if (! q) {q = l [n] = []; if (! r.setup || r. setup.call (с, г, р, м) === 1) c.addEventListener c.addEventListener (п, т, 1):!?! c.attachEvent && c.attachEvent ( "на" + п, м)} г .add && (r.add.call (с, к), j.handler.guid || (j.handler.guid = f.guid)), q.push (к), d.event.global [п] = ! 0} с = NULL}}, глобальная: {}, удалить: функция (а, в, д,f) {if (a.nodeType! == 3 && a.nodeType! == 8) {e ===! 1 && (e = x); var g, h, i, j, k = 0, l, m, n , о, р, д, г, з = d.hasData (а) && d._data (а), т = s && s.events; если (ы || т!!) возвращение; C && && Тип Ç (е = c.handler , c = c.type); if (! c || typeof c === "string" && c.charAt (0) === ".") {c = c || ""; для (h in t) d.event.remove (a, h + c); return} c = c.split (""); while (h = c [k ++]) {r = h, q = null, l = h.indexOf (" . ") <0, m = [], l || (m = h.split (". "), H = m.shift (), n = новый RegExp (" (^ | \\.) "+ D .map (m.slice (0) .sort (), ж) .join ( "\\ (:.?.. * \\)") + "(. \\ | $)")), р = т [ч], если (! р) продолжить, если {для (е!) (J = 0, J <p.length; j ++) {д = р [J], если (л || n.test (д .namespace)) d.event.remove (а, г, q.handler, J), p.splice (J - 1)}} продолжить о = d.event.special [ч] || {}; для (J = е || 0, J <p.length; j ++) {д = р [J], если (e.guid === q.guid) {если (л || n.test (кв.Пространство имен)) е == NULL && p.splice (J -, 1), o.remove && o.remove.call (а, д), если (е = нуль) перерыв}} если (p.length === 0 |! |! е = NULL && p.length === 1) (! o.teardown || o.teardown.call (а, т) === 1) && d.removeEvent (а, ч, s.handle), г = null, удалить t [h]} if (d.isEmptyObject (t)) {var u = s.handle; u && (u.elem = null), удалить s.events, удалить s.handle, d.isEmptyObject (s) && d.removeData (a, b,! 0)}}}, триггер: функция (a, c, e) {var f = a.type || a, g = arguments [3]; if (! g) {a = typeof a === "object"? a [d.expando]? a: d.extend (d.Event (f), a): d.Event (f), f.indexOf ("!")> = 0 && (a.type = F = f.slice (0, -1), a.exclusive =! 0), е || (a.stopPropagation (), d.event.global [F] && d.each (д. кэш, функция () {var b = d.expando, e = this [b]; e && e.events && e.events [f] && d.event.trigger (a, c, e.handle.elem)})); if ( ! e || e.nodeType === 3 || e.nodeType === 8) return b; a.result = b, a.target = e, c = d.makeArray (c), c.unshift (a)} a.currentTarget = e; var h = d._data (e, "handle"); h && h.apply ( e, c); var i = e.parentNode || e.ownerDocument; try {e && e.nodeName && d.noData [e.nodeName.toLowerCase ()] || e ["on" + f] && e ["on" + f ] .Нанесите (е, с) ===! 1 && (a.result =! 1, a.preventDefault ())} задвижка (к) {}, если (! a.isPropagationStopped () && я) d.event.trigger ( a, c, i,! 0), иначе if (! a.isDefaultPrevented ()) {var k, l = a.target, m = f.replace (r, ""), n = d.nodeName (l, "а") && м === "нажмите кнопку", о = d.event.special [м] || {}; если ((o._default || o._default.call (е, а) ===! 1) &&! п &&! (л && && l.nodeName d.noData [l.nodeName.toLowerCase ()])) {попытка {L [м] && (к = L [ "на" + т], к && (л [ "на" + т] = нуль), d.event.triggered = a.type, л [м] ())} задвижка (р) {} к && (л [»на "+ m] = k), d.event.triggered = b}}}, обрабатывать: function (c) {var e, f, g, h, i, j = [], k = d.makeArray (arguments ); ""! с = к [0] = d.event.fix (с || a.event), c.currentTarget = это, е = c.type.indexOf () <0 && c.exclusive, е | | (g = c.type.split ("."), c.type = g.shift (), j = g.slice (0) .sort (), h = новый RegExp ("(^ | \\. ) "+ j.join (" \\ (:.?.. * \\?). ") +" (\\ | $) ")), c.namespace = c.namespace || j.join (" . "), i = d._data (this," events "), f = (i || {}) [c.type]; if (i && f) {f = f.slice (0); для (var l = 0, m = f.length; l <m; l ++) {var n = f [l]; if (e || h.test (n.namespace)) {c.handler = n.handler, c.data = n.data, c.handleObj = n; var o = n.handler.apply (this, k); o! == b && (c.result = o, o ===! 1 && (c.preventDefault (), c.stopPropagation ())); if (c.isImmediatePropagationStopped ()) break}}} return c.result}, props: "altKey attrChange attrName пузыри кнопка отменяемый charCode clientX clientY ctrlKey элемент данных currentTarget eventPhase fromElement обработчик keyCode layerX layerY metaKey newValue offsetX pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey колесная функция, предназначенная для других целей: ) {if (a [d.expando]) возвращает a; var e = a; a = d.Event (e); for (var f = this.props.length, g; f;) g = this.props [ --f], а [г] = е [г]; a.target || (a.target = a.srcElement || с), a.target.nodeType === 3 && (a.target = a.target .parentNode) ,! a.relatedTarget && && a.fromElement (a.relatedTarget = a.fromElement === a.target?a.toElement:a.fromElement);if(a.pageX==null&&a.clientX!=null){var ч = c.documentElement, I = c.body; a.pageX = a.clientX + (ч && h.scrollLeft || я || && i.scrollLeft 0) - (ч && ч.clientLeft || я && i.clientLeft || 0), a.pageY = a.clientY + (ч && h.scrollTop || я || && i.scrollTop 0) - (ч && h.clientTop || я || && i.clientTop 0)} = a.which = NULL && (a.charCode = NULL || a.keyCode = нуль!) && (a.which = a.charCode = нуль a.charCode:? a.keyCode) ,! a.metaKey && a.ctrlKey && (a.metaKey = a.ctrlKey) ,! a.which && a.button! == b && (a.which = a.button & 1? 1: a.button & 2? 3: a.button & 4? 2: 0); вернуть a}, guid: 1e8, прокси: d.proxy, специальный: {готов: {установка: d.bindReady, демонтаж: d.noop}, живой: {дополнит: функция (а) {d.event.add (это, H (a.origType, .Селекторный), d.extend ({}, а, {обработчик: G, GUID: a.handler.guid}))}, удалить: функция (а) {d.event.remove (это, Н (a.origType , a.selector), а)}}, beforeunload: {настройки: функция (а, б, в) {d.isWindow (это) && (this.onbeforeunload = C)}, Teardown: функцию (а, б) { this.onbeforeunload === б && (это.onbeforeunload = NULL)}}}}, d.removeEvent = c.removeEventListener функция (а, б, в) {a.removeEventListener && a.removeEventListener (б, в, 1)}:?! функция (а, б, в) { a.detachEvent && a.detachEvent ("on" + b, c)}, d.Event = function (a) {if (! this.preventDefault) вернуть новый d.Event (a); a && a.type? (this.originalEvent = ! а, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || a.returnValue === 1 || a.getPreventDefault && a.getPreventDefault () у: х): this.type = а, это. timeStamp = d.now (), this [d.expando] =! 0}, d.Event.prototype = {protectDefault: function () {this.isDefaultPrevented = y; var a = this.originalEvent; a && (a.preventDefault ? a.preventDefault (): a.returnValue =! 1)}, stopPropagation: function () {this.isPropagationStopped = y; var a = this.originalEvent; a && (a.stopPropagation && a.stopPropagation (), a.cancelBubble =! 0)}, stopImmediatePropagation:function () {this.isImmediatePropagationStopped = y, this.stopPropagation ()}, isDefaultPrevented: x, isPropagationStopped: x, isImmediatePropagationStopped: x}; var z = function (a) {var b = a.relatedTarget; try {if (b & b&) ! == с && b.parentNode) возвращение;!, а (б && Ь == это) б = b.parentNode;! б == это && (a.type = a.data, d.event.handle.apply (это, аргументы ))} поймать (е) {}}, А = функция (а) {a.type = a.data, d.event.handle.apply (это, аргументы)}; d.each ({MouseEnter: "Mouseover" , MouseLeave: "MouseOut"}, функцию (а, б) {d.event.special [а] = {настройки: функция (с) {d.event.add (это, B, C && c.selector A:? г, а)}, демонтажа: функция (а) {d.event.remove (это, Ь, а && a.selector A: г)}}}), d.support.submitBubbles || (d.event.special.submit = {установка: (! this.nodeName && this.nodeName.toLowerCase () == "форма") функция (а, Ь) {если d.event.add (это, "нажмите кнопку.specialSubmit ", function (a) {var b = a.target, c = b.type; (c ===" submit "|| c ===" image ") && d (b) .closest (" form ") .length && E ("submit", this, arguments)}), d.event.add (this, "keypress.specialSubmit", function (a) {var b = a.target, c = b.type; (c == = "text" || c === "пароль") && d (b) .closest ("form"). length && a.keyCode === 13 && E ("submit", this, arguments)}); в противном случае верните! 1} , teardown: function (a) {d.event.remove (this, ". specialSubmit")}}); if (! d.support.changeBubbles) {var B, C = function (a) {var b = a. типа, с = a.value; б === "радио" || б === "флажок" с = a.checked: === б "выбрать-кратно" с = a.selectedIndex> -1? d.map (a.options, function (a) {return a.selected}). join ("-"): "": a.nodeName.toLowerCase () === "select"&& (c = a.selectedIndex); вернуть c}, D = функция D (a) {var c = a.target, e, f; if (s.test (c.nodeName) &&! c.readOnly) {e = d._data (с, "_ change_data"), е = С (с), (a.type! == "focusout" || Тип Ç! == "радио") && d._data (с, "_ change_data" , е), если (е === Ь || е === е) возврат, если (е = нуль || е) a.type = "изменение", a.liveFired = Ь, d.event.trigger! (a, arguments [1], c)}}; d.event.special.change = {filters: {focusout: D, перед деактивацией: D, нажмите: function (a) {var b = a.target, c = b .type; (с === "радио" || с === "флажок" || b.nodeName.toLowerCase () === "выбрать") && D.call (это, а)}, KeyDown: функция ( a) {var b = a.target, c = b.type; (a.keyCode === 13 && b.nodeName.toLowerCase ()! == "textarea" || a.keyCode === 32 && (c === "флажок" || с === "радио") || с === "выбрать-кратно") && D.call (это,a)}, beforeactivate: function (a) {var b = a.target; d._data (b, "_ change_data", C (b))}}, setup: function (a, b) {if (this.type === "file") return! 1; for (var c in B) d.event.add (this, c + ". specialChange", B [c]); return s.test (this.nodeName)}, разрыв : function (a) {d.event.remove (this, ". specialChange"); вернуть s.test (this.nodeName)}}, B = d.event.special.change.filters, B.focus = B. beforeactivate} c.addEventListener && d.each ({focus: "focusin", blur: "focusout"}, function (a, b) {function f (a) {var c = d.event.fix (a); c.type = b, c.originalEvent = {}, d.event.trigger (c, null, c.target), c.isDefaultPrevented () && a.preventDefault ()} var e = 0; d.event.special [b] = {настройка: функция () {е ++ === 0 && c.addEventListener (а, е, 0!)}, демонтаж: функция () {- е === 0 && c.removeEventListener (! а, е, 0)}}} ), d.each ([ "связывать", "один"],function (a, c) {d.fn [c] = function (a, e, f) {if (typeof a === "object") {для (var g in a) этого [c] (g, e , a [g], f); вернуть это}, если (d.isFunction (e) || e ===! 1) f = e, e = b; var h = c === "one"? d. proxy (f, function (a) {d (this) .unbind (a, h); вернуть f.apply (this, аргументы)}): f; if (a === "unload" && c! == "one ") this.one (a, e, f); еще для (var i = 0, j = this.length; i <j; i ++) d.event.add (this [i], a, h, e) ; вернуть это}}), d.fn.extend ({unbind: function (a, b) {if (typeof a! == "object" || a.preventDefault) для (var e = 0, f = this. длина; e <f; e ++) d.event.remove (this [e], a, b); еще для (var c in a) this.unbind (c, a [c]); вернуть this}, делегировать: function (a, b, c, d) {вернуть this.live (b, c, d, a)}, undelegate: function (a, b, c) {вернуть arguments.length === 0? this.unbind ( "live"): this.die (b, null, c, a)}, триггер: function (a, b) {вернуть this.each (function () {d.event.trigger (a, b, this)} )},triggerHandler: function (a, b) {if (this [0]) {var c = d.Event (a); c.preventDefault (), c.stopPropagation (), d.event.trigger (c, b, this [0]); return c.result}}, toggle: function (a) {var b = arguments, c = 1; while (c <b.length) d.proxy (a, b [c ++]); вернуть это .click (d.proxy (a, function (e) {var f = (d._data (this, "lastToggle" + a.guid) || 0)% c; d._data (this, "lastToggle" + a .guid, f + 1), e.preventDefault (); return b [f] .apply (this, arguments) ||! 1}))}, hover: function (a, b) {return this.mouseenter (a ) .mouseleave (b || a)}}); var F = {focus: "focusin", blur: "focusout", mouseenter: "mouseover", mouseleave: "mouseout"}; d.each (["live" , "die"], function (a, c) {d.fn [c] = function (a, e, f, g) {var h, i = 0, j, k, l, m = g || this .selector, n = g? this: d (this.context); if (typeof a === "object" &&! a.preventDefault) {for (var o in a) n [c] (o, e, a [о], м);вернуть это} d.isFunction (e) && (f = e, e = b), a = (a || ""). split (""); while ((h = a [i ++])! = null) {J = r.exec (ч), к = "", J && (к = у [0], ч = h.replace (г "")); если (ч === "парения") {а. толчок ( "MouseEnter" + к, "MouseLeave" + К)? продолжать} L = H, H === "фокус" || час === "смазанности" (a.push (F [ч] + к) , h = h + k): h = (F [h] || h) + k; если (c === "live") для (var p = 0, q = n.length; p <q; p ++ ) d.event.add (п [р], "вживую". + Н (Н, м), {данные: е, селектор: м, обработчик: F, OrigType: ч, origHandler: F, preType: л}) ; иначе n.unbind ("live." + H (h, m), f)} вернуть это}}), d.each ("размытие фокуса в фокусе при загрузке с изменением размера прокрутки выгрузить щелчок dblclick mousedown mouseup mousemove mouseover выберите отправить сообщение об ошибке нажатия клавиши ".split (" "), function (a, b) {d.fn [b] = function (a,c) {c == null && (c = a, a = null); вернуть arguments.length> 0? this.bind (b, a, c): this.trigger (b)}, d.attrFn && (d.attrFn [b] =! 0)}), function () {function u (a, b, c, d, e, f) {for (var g = 0, h = d.length; g <h; g ++) { var i = d [g]; if (i) {var j =! 1; i = i [a]; while (i) {if (i.sizcache === c) {j = d [i.sizset] ; break} if (i.nodeType === 1) {f || (i.sizcache = c, i.sizset = g); if (typeof b! == "string") {if (i === b ) {j =! 0; break}} иначе if (k.filter (b, [i]). length> 0) {j = i; break}} i = i [a]} d [g] = j} }} функция t (a, b, c, d, e, f) {для (var g = 0, h = длина d; g <h; g ++) {var i = d [g]; if (i) {var j =! 1; i = i [a]; while (i) {if (i.sizcache === c) {j = d [i.sizset]; break} i.nodeType === 1 &&! f && (i.sizcache = с, i.sizset = г); если (i.nodeName.toLowerCase () === б) {J = я;} разрыва I = [а]} д [г] = J}} } var a = / ((?: \ ((?: \ ([^ ()] + \) | [^ ()] +) + \) | \ [(?: \ [[^ \ [\]] * \] | ['"] [^'"] * ['"] | [^ \ [\]'"] +) + \] | \\. | [^> + ~,(\ [\\] +) + | [> + ~]) (\ s * \ S *) ((: |?. \ Г | \ п) *) / г, е = 0, е = Объект .prototype.toString, g =! 1, h =! 0, i = / \\ / g, j = / \ W /; [0,0] .sort (function () {h =! 1; return 0} ); var k = function (b, d, e, g) {e = e || [], d = d || c; var h = d; if (d.nodeType! == 1 && d.nodeType! == 9) return []; if (! B || typeof b! == "string") return e; var i, j, n, o, q, r, s, t, u =! 0, w = k. isXML (д), х = [], у = Ь; делать {a.exec ( ""), I = a.exec (у), если (я) {у = I [3], x.push (я [1]); если (я [2]) {о = я [3]; перерыв}}}, а (я), если (x.length> 1 && m.exec (б)), если (x.length === 2 && l.relative [х [0]]) J = v (х [0] + х [1], д); еще {J = l.relative [х [0]] [d]: к (x.shift? (в), г), в то время (x.length) Ь = x.shift (), l.relative [Ь] && (Ь + = x.shift ()), J = V (B, J)} еще {г && х! .length> 1 && d.nodeType === 9 &&! ш && l.match.ID.test (х [0]) &&! l.match.ID.test (х [x.length-1]) && (д = k.find (x.shift (), д, ш), г = q.expr k.filter (q.expr, q.set) [0]: q.set [0]);если (д) {д = г {выражение: x.pop (), набор: р (г)}: k.find (x.pop (), x.length === 1 && (х [0] == = "~" || х [0] === "+") && d.parentNode d.parentNode: д, ш), J = q.expr k.filter (q.expr, q.set): д ? .set, x.length> 0 п = р (к):? и = 1, в то время (x.length) г = x.pop (), с = г, l.relative [г] с = х. pop (): r = "", s == null && (s = d), l.relative [r] (n, s, w)}, иначе n = x = []} n || (n = j), n || k.error (r || b); if (f.call (n) === "[object Array]") if (u) if (d && d.nodeType === 1) для (t = 0 ; п [т] = NULL;! т ++), п [т] && (! п [т] === 0 || п [п] .nodeType === 1 && k.contains (д, п [т])) && е .push (j [t]); еще для (t = 0; n [t]! = null; t ++) n [t] && n [t] .nodeType === 1 && e.push (j [t]); еще e.push.apply (e, n); иначе p (n, e); o && (k (o, h, e, g), k.uniqueSort (e)); вернуть e}; k.uniqueSort = function ( a) {if (r) {g = h, a.sort (r); if (g) для (var b = 1; b <a.length; b ++) a [b] === a [b-1 ] && a.splice (b -, 1)} return a},k.matches = function (a, b) {return k (a, null, null, b)}, k.matchesSelector = function (a, b) {return k (b, null, null, [a]). length > 0}, k.find = function (a, b, c) {var d; if (! A) return []; for (var e = 0, f = l.order.length; e <f; e ++) {var g, h = l.order [e]; if (g = l.leftMatch [h] .exec (a)) {var j = g [1]; g.splice (1,1); if (j .substr (j.length-1)! == "\\") {г [1] = (г [1] || ""). заменить (I ""), д = l.find [ч] (g, b, c); if (d! = null) {a = a.replace (l.match [h], ""); break}}}} d || (d = typeof b.getElementsByTagName! = = "undefined"? b.getElementsByTagName ("*"): []); return {set: d, expr: a}}, k.filter = function (a, c, d, e) {var f, g, h = a, i = [], j = c, m = c && c [0] && k.isXML (c [0]); while (a && c.length) {for (var n в l.filter) if ((f = l.leftMatch [n] .exec (a))! = null && f [2]) {var o, p, q = l.filter [n], r = f [1]; g =! 1, f.splice ( 1,1); если (r.substr (r.length-1) === "\\") продолжить;J === я && (я = []); если (l.preFilter [п]) {е = l.preFilter [п] (F, J, D, I, е, м); если (е) {если (f ===! 0) продолжить} иначе g = o =! 0} if (f) для (var s = 0; (p = j [s])! = null; s ++) if (p) {o = q (p, f, s, j); var t = e ^ !! o; d && o! = null? t? g =! 0: j [s] =! 1: t && (i.push (p), g ! = 0)}, если (о == б) {д || (J = I), а = a.replace (l.match [п], "");!, если (г) возвращение []; перерыв }} if (a === h) if (g == null) k.error (a); else break; h = a} return j}, k.error = function (a) {throw "Синтаксическая ошибка, нераспознанная выражение: "+ a}; var l = k.selectors = {order: [" ID "," NAME "," TAG "], соответствие: {ID: / # ((?: [\ w \ u00c0- \ uFFFF . \ -] | \\) +) / КЛАСС: / \ ((:.?. [\ ш \ u00c0- \ uFFFF \ -] | \\) +) /, иМЯ: / \ [имя = [» "] * ((?:. [\ ш \ u00c0- \ uFFFF \ -] | \\) +) [ '"] * \] /, ATTR: / \ [\ s * ((: [\ ш \? . u00c0- \ uFFFF \ -] | \\) +) \ S * ((\ S =) \ s * (([ ' "]??) (*.?) \ 3 | (# (? :.? [\ ш \ u00c0- \ uFFFF \ -] | \\) *) |) |) \ s * \] /, TAG: / ^ ((: [\ ш \ u00c0- \ uFFFF \ * \ -] | \\) +) /, РЕБЕНОК:. /:(Только | энный | последняя | первый) -child (: \ (\ s * (даже | нечетный | (?:? [+ \ -] \ d + | (: [+ \ -] \ d *)?? N \ s *: -)) \ s * \)) /, POS ([+ \] \ s * \ d +?):? / :( п-я | э | GT | л | первый | последний | четный | нечетная ) (?: \ ((\ d *) \)?) (= [^ \ -] | $) /, пСЕВДО: /: ((?: [\ ш \ u00c0- \ uFFFF \ -] | \\ .) +) (: \ (([ ' "]?)? ((?: \ ([^ \)] + \) | [^ \ (\)] *) +) \ 2 \)) /} , leftMatch: {}, attrMap: {"class": "className", "for": "htmlFor"}, attrHandle: {href: function (a) {вернуть a.getAttribute ("href")}, тип: function (a) {return a.getAttribute ("type")}}, относительный: {"+": function (a, b) {var c = typeof b === "string", d = c &&! j.test ( b), e = c &&! d; d && (b = b.toLowerCase ()); для (var f = 0, g = a.length, h; f <g; f ++) if (h = a [f]) {в то время как ((Н = h.previousSibling) && h.nodeType == 1) {} а [е] = е || ч && h.nodeName.toLowerCase () === б ч ​​|| 1:! ч === б} е && k.filter (Ь, а, 0!)}, ">": функция (а,b) {var c, d = typeof b === "string", e = 0, f = a.length; if (d &&! j.test (b)) {b = b.toLowerCase (); for (; e <f; e ++) {c = a [e]; if (c) {var g = c.parentNode; a [e] = g.nodeName.toLowerCase () === b? g:! 1}}} еще {для (; е <е, е ++), с = а [е], с &&! (а [е] = d c.parentNode: c.parentNode === б); г && k.filter (Ь, а, 0 )}}, "": function (a, b, c) {var d, f = e ++, g = u; typeof b === "string" &&! j.test (b) && (b = b.toLowerCase (), d = b, g = t), g ("parentNode", b, f, a, d, c)}, "~": функция (a, b, c) {var d, f = e ++, g = u; typeof b === "string" &&! j.test (b) && (b = b.toLowerCase (), d = b, g = t), g ("previousSibling", b, f, a , d, c)}}, найдите: {ID: function (a, b, c) {if (typeof b.getElementById! == "undefined" &&! c) {var d = b.getElementById (a [1] ); вернуть d && d.parentNode? [d]: []}}, NAME: function (a, b) {if (typeof b.getElementsByName! == "undefined ") {var c = [], d = b.getElementsByName (a [1]); для (var e = 0, f = d.length; e <f; e ++) d [e] .getAttribute (" name ") === a [1] && c.push (d [e]); return c.length === 0? null: c}}, TAG: function (a, b) {if (typeof b.getElementsByTagName! == "undefined") return b.getElementsByTagName (a [1])}}, preFilter: {CLASS: функция (a, b, c, d, e, f) {a = "" + a [1] .replace (i, "") + ""; если (f) вернуть a; for (var g = 0, h; (h = b [g])! = null; g ++) h && (e ^ (h.className && (" "+ h.className +" ") .replace (/ [\ t \ n \ r] / g," ") .indexOf (a)> = 0)? c || d.push (h): c && (b [ g] =! 1)); return! 1}, ID: function (a) {return a [1] .replace (i, "")}, TAG: function (a, b) {return a [1]. заменить (я "") toLowerCase ()}, РЕБЕНОК:. функция (а) {если (а [1] === "п-й") {а [2] || k.error (а [0]), а [2] = а [2] .Надеть (/ ^ \ + | \ s * / г, "");var b = / (-?) (\ d *) (?: n ([+ \ -]? \ d *))? /. exec (a [2] === "even" && "2n" || а [2] === "нечетным" && "2n + 1" || / \ Д / .test (а [2]) && "0n +" + а [2] || а [2]);! а [ 2] = b [1] + (b [2] || 1) -0, a [3] = b [3] -0} иначе a [2] && k.error (a [0]); a [0 ] = e ++; вернуть a}, ATTR: функция (a, b, c, d, e, f) {var g = a [1] = a [1] .replace (i, "") ;! f && l.attrMap [г] && (а [1] = l.attrMap [г]), а [4] = (а [4] || а [5] || ""). заменить (I ""), а [ 2] === "~ =" && (a [4] = "" + a [4] + ""); вернуть a}, PSEUDO: функция (b, c, d, e, f) {if (b [1] === "нет"), если ((a.exec (б [3]) || ""). длина> 1 || / ^ \ ж / .test (б [3])) б [3 ] = k (b [3], null, null, c); иначе {var g = k.filter (b [3], c, d,! 0 ^ f); d || e.push.apply (e , g); вернуть! 1} иначе, если (l.match.POS.test (b [0]) || l.match.CHILD.test (b [0])) вернуть! 0; вернуть b}, POS: function (a) {a.unshift (! 0); вернуть a}},фильтры: {enabled: function (a) {return a.disabled ===! 1 && a.type! == "hidden"}, отключено: function (a) {return a.disabled ===! 0}, проверено: function (a) {return a.checked ===! 0}, выбранный: function (a) {a.parentNode && a.parentNode.selectedIndex; return a.selected ===! 0}, родительский: function (a) {return! ! a.firstChild}, пустые: функция (а) {возвращение a.firstChild}, имеет: функцию (а, б, в) {возвращение !! К (С [3], а) .length}, заголовок: функция (a) {return / h \ d / i.test (a.nodeName)}, text: function (a) {var b = a.getAttribute ("type"), c = a.type; return "text" = == с && (б === с || Ь === NULL)}, радио: функция (а) {возвращение "радио" === a.type}, флажок: функция (а) {возвращение "флажок" = == a.type} файла: функция (а) {возвращение "файл" === a.type}, пароль: функция (а) {возвращение "пароль" === a.type}, представляет: функцию (а ) {возвращение "отправить" === a.type}, изображение:Функция (а) {возвращение "изображение" === a.type}, сброс: функция (а) {возвращение "сброс" === a.type}, кнопка: функция (а) "Кнопка" {возвращение === a.type || "кнопка" a.nodeName.toLowerCase () ===}, вход: функция (а) {возврат / вход | выбрать | текстовое поле | кнопка / i.test (a.nodeName)}}, setFilters: {first: function (a, b) {return b === 0}, last: function (a, b, c, d) {return b === d.length-1}, даже: function (a, b ) {return b% 2 === 0}, нечетное: function (a, b) {return b% 2 === 1}, lt: function (a, b, c) {return b <c [3] - 0}, gt: function (a, b, c) {return b> c [3] -0}, nth: function (a, b, c) {return c [3] -0 === b}, eq : function (a, b, c) {return c [3] -0 === b}}, фильтр: {PSEUDO: function (a, b, c, d) {var e = b [1], f = l.filters [e]; if (f) возвращает f (a, c, b, d); if (e === "содержит") return (a.textContent || a.innerText || k.getText ([ a]) || ""). indexOf (b [3])> = 0; если (e === "not") {var g = b [3]; для (var h = 0, i = g. длина; ч <я;h ++) if (g [h] === a) return! 1; return! 0} k.error (e)}, CHILD: function (a, b) {var c = b [1], d = a; переключатель (с) {случай "только": случай "первый": в то время как (д = d.previousSibling), если (d.nodeType === 1) возвращение 1; если (с === "первый") возвращает 0! ; d = a; case "last": while (d = d.nextSibling) if (d.nodeType === 1) возвращает! 1; возвращает! 0; case "nth": var e = b [2], f = b [3]; if (e === 1 && f === 0) вернуть! 0; var g = b [0], h = a.parentNode; if (h && (h.sizcache! == g ||! a.nodeIndex)) {var i = 0; for (d = h.firstChild; d; d = d.nextSibling) d.nodeType === 1 && (d.nodeIndex = ++ i); h.sizcache = g} var j = a.nodeIndex-f; вернуть e === 0? j === 0: j% e === 0 && j / e> = 0}}, ID: function (a, b) {вернуть a.nodeType === 1 && a.getAttribute ("id") === b}, TAG: function (a, b) {return b === "*" && a.nodeType === 1 || a.nodeName.toLowerCase () === b}, CLASS: function (a, b) {return ("" + (a.className || a.getAttribute ("class")) + "") .indexOf (b)> - 1}, ATTR: функция (a, b) {var c = b [1], d = l.attrHandle [c]? l.attrHandle [c] (a): a [c]! = null? a [c]: a.getAttribute (c), e = d + "", f = b [2], g = b [4]; возврат d = ? = NULL е === "=!": е === "=" е === г: е === "=" e.indexOf (г)> = 0: F ===» ~ = "? (" "+ e +" ") .indexOf (g)> = 0: g? f ==="! = "? e! == g: f ===" ^ = "? e.indexOf (г) === 0: F === "$ =" e.substr (e.length-g.length) === г:? е === "| =" е === г || e.substr (0, g.length + 1) === g + "-" :! 1: e && d! ==! 1}, POS: функция (a, b, c, d) {var e = b [2 ], f = l.setFilters [e]; if (f) возвращает f (a, c, b, d)}}}, m = l.match.POS, n = function (a, b) {return "\ \ "+ (b-0 + 1)}; для (var o в l.match) l.match [o] = новый RegExp (l.match [o] .source + / (?! [^ \ [] * \ ]) (?! [^ \ (] * \)) /. source), l.leftMatch [o] = new RegExp (/ (^ (?:. | \ r | \ n) *?) /. source + л.match [o] .source.replace (/ \\ (\ d +) / g, n)); var p = function (a, b) {a = Array.prototype.slice.call (a, 0); if ( b) {b.push.apply (b, a); return b} return a}; try {Array.prototype.slice.call (c.documentElement.childNodes, 0) [0] .nodeType} catch (q) { p = function (a, b) {var c = 0, d = b || []; if (f.call (a) === "[object Array]") Array.prototype.push.apply (d, a); иначе if (typeof a.length === "number") для (var e = a.length; c <e; c ++) d.push (a [c]); еще для (; a [c] ; c ++) d.push (a [c]); return d}} var r, s; c.documentElement.compareDocumentPosition? r = function (a, b) {if (a === b) {g =! 0 ; return 0} if (! a.compareDocumentPosition ||! b.compareDocumentPosition) return a.compareDocumentPosition? -1: 1; return a.compareDocumentPosition (b) & 4? -1: 1} :( r = function (a, b ) {var c, d, e = [], f = [], h = a.parentNode, i = b.parentNode, j = h; if (a === b) {g =! 0; вернуть 0} if (h === i) возвращает s (a, b); if (! h) return-1; if (! i) возвращает 1; while (j) e.unshift (j),j = j.parentNode; j = i; while (j) f.unshift (j), j = j.parentNode; c = длина e, d = f.length; для (var k = 0; k <c && k < d; k ++) if (e [k]! == f [k]) вернуть s (e [k], f [k]); вернуть k === c? s (a, f [k], - 1 ): s (e [k], b, 1)}, s = функция (a, b, c) {if (a === b) return c; var d = a.nextSibling; while (d) {if (d === b) return-1; d = d.nextSibling} return 1}), k.getText = function (a) {var b = "", c; для (var d = 0; a [d] ?!; d ++), с = а [г], c.nodeType === 3 === || c.nodeType 4 Ь + = c.nodeValue: c.nodeType == 8 && (B + = k.getText (c.childNodes )); return b}, function () {var a = c.createElement ("div"), d = "script" + (новая дата) .getTime (), e = c.documentElement; a.innerHTML = "< a name = '"+ d +"' /> ", e.insertBefore (a, e.firstChild), c.getElementById (d) && (l.find.ID = function (a, c, d) {if (typeof) c.getElementById! == "undefined" &&! d) {var e = c.getElementById (a [1]); вернуть e? e.id === a [1] || typeof e.getAttributeNode! == "undefined" && e.getAttributeNode ("id"). nodeValue === a [1]? [e]: b: []}}, l .filter.ID = function (a, b) {var c = typeof a.getAttributeNode! == "undefined" && a.getAttributeNode ("id"); вернуть a.nodeType === 1 && c && c.nodeValue === b}) , e.removeChild (a), e = a = null} (), function () {var a = c.createElement ("div"); a.appendChild (c.createComment ("")), a.getElementsByTagName ( "*"). длина> 0 && (l.find.TAG = function (a, b) {var c = b.getElementsByTagName (a [1]); if (a [1] === "*") {var d = []; для (var e = 0; c [e]; e ++) c [e] .nodeType === 1 && d.push (c [e]); c = d} return c}), a.innerHTML = "<a href='#'> </a>", a.firstChild && typeof a.firstChild.getAttribute! == "undefined" && a.firstChild.getAttribute ("href ")! ==" # "&& (l.attrHandle.href = function (a) {return a.getAttribute (" href ", 2)}), a = null} (), c.querySelectorAll && function () {var a = k, b = c.createElement ("div"), d = "__ sizzle __"; b.innerHTML = "<p class = 'TEST'> </ p>"; if (! b.querySelectorAll || b. querySelectorAll (". TEST"). length! == 0) {k = функция (b, e, f, g) {e = e || c; if (! g &&! k.isXML (e)) {var h = / ^ (\ ш + $) | ^ \ ([\ ш \ -] + $) | ^ # ([\ ш \ -] + $) / Exec (б).. если (ч && (e.nodeType = == 1 || e.nodeType === 9)) {if (h [1]) return p (e.getElementsByTagName (b), f); if (h [2] && l.find.CLASS && e.getElementsByClassName) return p (e.getElementsByClassName (h [2]), f)} if (e.nodeType === 9) {if (b === "body" && e.body) возвращает p ([e.body], f) ; if (h && h [3]) {var i = e.getElementById (h [3]); if (! i ||! i.parentNode) возвращает p ([], f); if (i.id === h [3]) return p ([i], f)} try {return p (e.querySelectorAll (b), f)} catch (j) {}} else if (e.nodeType === 1 && e.nodeName.toLowerCase ()! == "object") {var m = e, n = e.getAttribute ("id"), o = n || d, q = e.parentNode, r = / ^ \ s * [+ ~] / тест (б); п о = o.replace (/ '/ г, "\\ $ &"):.? e.setAttribute ( "ID", о), г && && д (е = е. parentNode); try {if (! r || q) return p (e.querySelectorAll ("[id = '" + o + "']" + b), f)} catch (s) {} finally {n || m.removeAttribute ("id")}}} возвращает a (b, e, f, g)}; для (var e in a) k [e] = a [e]; b = null}} (), функция () {var a = c.documentElement, b = a.matchesSelector || a.mozMatchesSelector || a.webkitMatchesSelector || a.msMatchesSelector; if (b) {var d =! b.call (c.createElement ("div ")," DIV "), е = 1, попытка {b.call (c.documentElement,!" [тест = '']: шипение ")} поймать (е) {е = 0!} к.matchesSelector = функция (а, с) {с = c.replace (/ \ = \ s * ([^ ' "\]] *) \ s * \] / г," =' $ 1' ] "); если ( ! k.isXML (a)) try {if (e ||! l.match.PSEUDO.test (c) &&! /! = /. test (c)) {var f = b.call (a, c) ; if (f ||! d || a.document && a.document.nodeType! == 11) return f}} catch (g) {} return k (c, null, null, [a]). length> 0} }} (), function () {var a = c.createElement ("div"); a.innerHTML = "<div class = 'test e'> </ div> <div class = 'test'> </ div > "; если (a.getElementsByClassName && a.getElementsByClassName (" е ") длина == 0.!) {a.lastChild.className =" е "если (a.getElementsByClassName (". е ") длина === 1) return; l.order.splice (1,0, "CLASS"), l.find.CLASS = function (a, b, c) {if (typeof b.getElementsByClassName! == "undefined" &&! c) return b .getElementsByClassName (а [1])}, а = NULL}} (), с.documentElement.contains? k.contains = function (a, b) {return a! == b && (a.contains? a.contains (b) :! 0)}: c.documentElement.compareDocumentPosition? k.contains = function ( a, b) {return !! (a.compareDocumentPosition (b) & 16)}: k.contains = function () {return! 1}, k.isXML = function (a) {var b = (a? a.ownerDocument || a: 0) .documentElement; вернуть b? b.nodeName! == "HTML":! 1}; var v = function (a, b) {var c, d = [], e = "", f = b.nodeType [Ь]: б, в то время (с = l.match.PSEUDO.exec (а)) = е + с [0], а = a.replace (l.match.PSEUDO, ""); = l.relative [a]? a + "*": a; for (var g = 0, h = f.length; g <h; g ++) k (a, f [g], d); вернуть k.filter (е, д)}; d.find = к, d.expr = k.selectors, d.expr [ ":"] = d.expr.filters, d.unique = k.uniqueSort, d.text = K. getText, d.isXMLDoc = k.isXML, d.contains = k.contains} (); var I = / До $ /, J = / ^ (?: родители | prevUntil | prevAll) /, K = /, /, L = / ^ [^:. # \ [\,] * $ /, М = Array.prototype.slice, N = д..expr.match.POS, O = {children:! 0, содержимое:! 0, следующее:! 0, prev:! 0}; d.fn.extend ({find: function (a) {var b = this.pushStack ("", "найти", a), c = 0; для (var e = 0, f = this.length; e <f; e ++) {c = b.length, d.find (a, this [e ], b); если (e> 0) для (var g = c; g <b.length; g ++) для (var h = 0; h <c; h ++) if (b [h] === b [ g]) {b.splice (g -, 1); break}} return b}, имеет: function (a) {var b = d (a); вернуть this.filter (function () {for (var a = 0, c = b.length; a <c; a ++) if (d.contains (this, b [a])) return! 0})}, а не: function (a) {return this.pushStack (Q ( this, a,! 1), "not", a)}, filter: function (a) {return this.pushStack (Q (this, a,! 0), "filter", a)}, is: function ( a) {return !! a && d.filter (a, this) .length> 0}, ближайший: function (a, b) {var c = [], e, f, g = this [0]; if (d. isArray (a)) {var h, i, j = {}, k = 1; if (g && a.length) {for (e = 0, f = a.length; e <f; e ++) i = a [e ], J [г] || (J [I] = d.expr.match.POS.test (я)? д (I, B || это.контекст): i); while (g && g.ownerDocument && g! == b) {for (i in j) h = j [i], (h.jquery? h.index (g)> - 1: d (g). is (h)) && c.push ({селектор: i, элемент: g, уровень: k}); g = g.parentNode, k ++}} return c} var l = N.test (a)? d (a, б || this.context): нуль, ибо (е = 0, е = this.length; е <е, е ++) {г = это [е], в то время (г) {если (л l.index (г )> - 1:! d.find.matchesSelector (д, а)) {c.push (г); разрыв} г = g.parentNode; если (г || g.ownerDocument || г === б) break}} c = c.length> 1? d.unique (c): c; вернуть this.pushStack (c, "closest", a)}, index: function (a) {if (! a || typeof a === "string") вернуть d.inArray (this [0], a? d (a): this.parent (). children ()); вернуть d.inArray (a.jquery? a [0]: a , this)}, add: function (a, b) {var c = typeof a === "string"? d (a, b): d.makeArray (a), e = d.merge (this.get ( ), c); вернуть this.pushStack (P (c [0]) || P (e [0])? e: d.unique (e))} иSelf: function () {вернуть this.add (this .prevObsupportsFixedPosition && k.position === "фиксированные" && (L + = Math.max (h.scrollTop, i.scrollTop), т + = Math.max (h.scrollLeft, i.scrollLeft)); возвращение {сверху: л, слева: m}}, d.offset = {initialize: function () {var a = c.body, b = c.createElement ("div"), e, f, g, h, i = parseFloat (d.css (a , "marginTop")) || 0, j = "<div style = 'position: absolute; top: 0; left: 0; margin: 0; border: 5px solid # 000; отступ: 0; ширина: 1px; высота : 1px; '> <div> </ div> </ div> <table style =' position: absolute; top: 0; left: 0; margin: 0; border: 5px solid # 000; отступ: 0; ширина: 1px; высота: 1px;» cellpadding = '0' cellspacing = '0'> <tr> <td> </ td> </ tr> </ table> "; d.extend (b.style, {position:" absolute ", top: 0, слева направо: 0, запас: 0, граница: 0, ширина: "1px", высота: "1px", видимость: "скрытый"